// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SBA AI PROXY V4.0 - UNIVERSAL SPORTS EDITION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Deploy to Railway - replaces your current index.js
// 
// FEATURES:
// âœ… 11 AI Engines (ALL WORKING!)
// âœ… Sport-Specific Reddit (NBA, NFL, MLB, NHL, NCAAB, NCAAF, Soccer)
// âœ… Twitter/X Sentiment
// âœ… Live Game Tracking
// âœ… Highlightly API (14 endpoints - matches, predictions, odds, stats)
//
// V4.0 UPDATES:
// - Sport-specific subreddit searches
// - Cohere: command-a-03-2025 (newest model)
// - Grok: grok-3 (updated)
// - YouCom: Express Agent API
// - Highlightly NBA/NCAAB API integration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const express = require('express');
const cors = require('cors');
const fetch = require('node-fetch');

const app = express();
app.use(cors());
app.use(express.json({ limit: '10mb' }));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API KEYS (set these in Railway environment variables)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const KEYS = {
    anthropic: process.env.ANTHROPIC_API_KEY,
    openai: process.env.OPENAI_API_KEY,
    perplexity: process.env.PERPLEXITY_API_KEY,
    groq: process.env.GROQ_API_KEY,
    together: process.env.TOGETHER_API_KEY,
    deepseek: process.env.DEEPSEEK_API_KEY,
    cohere: process.env.COHERE_API_KEY,
    mistral: process.env.MISTRAL_API_KEY,
    google: process.env.GEMINI_API_KEY,  // Railway uses GEMINI_API_KEY
    xai: process.env.XAI_API_KEY,
    youcom: process.env.YOUCOM_API_KEY
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATUS ENDPOINT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.get('/', (req, res) => {
    // Check which keys are configured
    const configuredEngines = Object.entries(KEYS)
        .filter(([k, v]) => v && v.length > 0)
        .map(([k]) => k);
    
    res.json({
        status: 'SBA AI Proxy V4.0 - Universal Sports Edition',
        version: '4.0.0',
        engines: {
            total: 11,
            configured: configuredEngines.length,
            list: configuredEngines
        },
        features: [
            '11 AI engines (ALL WORKING)',
            'Sport-specific Reddit (NBA, NFL, MLB, NHL, etc.)',
            'Twitter/X sentiment',
            'Live game tracking',
            'Universal props thread scraping',
            'Highlightly API (14 endpoints)'
        ],
        endpoints: {
            ai: '/api/ai/:engine',
            aiStatus: '/api/ai/status',
            reddit: '/api/reddit/sentiment',
            twitter: '/api/twitter/sentiment',
            liveGame: '/api/live/:sport/:gameId',
            liveScores: '/api/live/:sport/scores',
            highlightly: '/api/highlightly/*'
        }
    });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AI ENGINE STATUS - Check which engines are available
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.get('/api/ai/status', (req, res) => {
    const status = {};
    for (const [engine, config] of Object.entries(ENGINE_CONFIGS)) {
        const key = KEYS[config.keyName];
        status[engine] = {
            configured: !!(key && key.length > 0),
            keyName: config.keyName,
            model: config.model
        };
    }
    res.json({ engines: status });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AI ENGINE CONFIGURATIONS (Updated with correct endpoints)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const ENGINE_CONFIGS = {
    claude: {
        url: 'https://api.anthropic.com/v1/messages',
        model: 'claude-sonnet-4-20250514',
        keyName: 'anthropic',
        format: 'anthropic'
    },
    openai: {
        url: 'https://api.openai.com/v1/chat/completions',
        model: 'gpt-4o',
        keyName: 'openai',
        format: 'openai'
    },
    perplexity: {
        url: 'https://api.perplexity.ai/chat/completions',
        model: 'sonar-pro',
        keyName: 'perplexity',
        format: 'openai'
    },
    groq: {
        url: 'https://api.groq.com/openai/v1/chat/completions',
        model: 'llama-3.3-70b-versatile',
        keyName: 'groq',
        format: 'openai'
    },
    together: {
        url: 'https://api.together.xyz/v1/chat/completions',
        model: 'meta-llama/Llama-3.3-70B-Instruct-Turbo',
        keyName: 'together',
        format: 'openai'
    },
    deepseek: {
        url: 'https://api.deepseek.com/chat/completions',
        model: 'deepseek-chat',
        keyName: 'deepseek',
        format: 'openai'
    },
    // FIXED: Cohere V2 API with newest model
    cohere: {
        url: 'https://api.cohere.com/v2/chat',
        model: 'command-a-03-2025',
        keyName: 'cohere',
        format: 'cohere_v2'
    },
    mistral: {
        url: 'https://api.mistral.ai/v1/chat/completions',
        model: 'mistral-large-latest',
        keyName: 'mistral',
        format: 'openai'
    },
    // FIXED: Gemini with correct model name
    gemini: {
        url: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent',
        model: 'gemini-2.0-flash',
        keyName: 'google',
        format: 'google'
    },
    // FIXED: Grok/xAI 
    grok: {
        url: 'https://api.x.ai/v1/chat/completions',
        model: 'grok-3',
        keyName: 'xai',
        format: 'openai'
    },
    // FIXED: You.com Express Agent API (new format as of Sep 2025)
    youcom: {
        url: 'https://api.you.com/v1/agents/runs',
        model: 'express',
        keyName: 'youcom',
        format: 'youcom_express'
    }
};

// Format request based on API type
function formatRequest(config, prompt, maxTokens = 800) {
    const key = KEYS[config.keyName];
    
    if (!key) {
        return null;
    }
    
    if (config.format === 'anthropic') {
        return {
            url: config.url,
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': key,
                'anthropic-version': '2023-06-01'
            },
            body: {
                model: config.model,
                max_tokens: maxTokens,
                messages: [{ role: 'user', content: prompt }]
            }
        };
    }
    
    if (config.format === 'google') {
        return {
            url: `${config.url}?key=${key}`,
            headers: { 'Content-Type': 'application/json' },
            body: {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { maxOutputTokens: maxTokens }
            }
        };
    }
    
    // FIXED: Cohere V2 format
    if (config.format === 'cohere_v2') {
        return {
            url: config.url,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${key}`
            },
            body: {
                model: config.model,
                messages: [{ role: 'user', content: prompt }]
                // Note: max_tokens is optional in Cohere V2, defaults to model max
            }
        };
    }
    
    // FIXED: You.com Express Agent API format (new as of Sep 2025)
    if (config.format === 'youcom_express') {
        return {
            url: config.url,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${key}`
            },
            body: {
                agent: 'express',
                input: prompt
            }
        };
    }
    
    // OpenAI format (default for most)
    return {
        url: config.url,
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${key}`
        },
        body: {
            model: config.model,
            max_tokens: maxTokens,
            messages: [{ role: 'user', content: prompt }]
        }
    };
}

// Parse response based on API type
function parseResponse(config, data) {
    if (config.format === 'anthropic') {
        return {
            raw: data.content?.[0]?.text,
            usage: data.usage
        };
    }
    
    if (config.format === 'google') {
        return {
            raw: data.candidates?.[0]?.content?.parts?.[0]?.text,
            usage: data.usageMetadata
        };
    }
    
    if (config.format === 'cohere_v2') {
        return {
            raw: data.message?.content?.[0]?.text || data.text,
            usage: data.usage
        };
    }
    
    // FIXED: You.com Express Agent API response format
    if (config.format === 'youcom_express') {
        // Express API returns: { output: [{ type: "...", text: "answer" }] }
        const output = data.output || [];
        const answerBlock = output.find(o => o.text) || output[0] || {};
        return {
            raw: answerBlock.text || answerBlock.answer || JSON.stringify(data),
            usage: { total_tokens: 0 } // Express API doesn't return token counts
        };
    }
    
    // OpenAI format (default)
    return {
        raw: data.choices?.[0]?.message?.content,
        usage: data.usage
    };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AI ENDPOINT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.post('/api/ai/:engine', async (req, res) => {
    const { engine } = req.params;
    const { prompt, maxTokens = 800 } = req.body;
    
    const config = ENGINE_CONFIGS[engine];
    if (!config) {
        return res.status(400).json({ error: `Unknown engine: ${engine}` });
    }
    
    const key = KEYS[config.keyName];
    if (!key) {
        return res.status(400).json({ 
            error: `No API key configured for ${engine}`,
            keyName: config.keyName,
            hint: `Set ${config.keyName.toUpperCase()}_API_KEY in Railway environment variables`
        });
    }
    
    try {
        const request = formatRequest(config, prompt, maxTokens);
        
        if (!request) {
            return res.status(400).json({ error: `Could not format request for ${engine}` });
        }
        
        const response = await fetch(request.url, {
            method: 'POST',
            headers: request.headers,
            body: JSON.stringify(request.body),
            timeout: 30000
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`${engine} error:`, response.status, errorText);
            return res.status(response.status).json({ 
                error: `${engine} API error: ${response.status}`,
                details: errorText.substring(0, 500)
            });
        }
        
        const data = await response.json();
        const result = parseResponse(config, data);
        
        // Try to parse as JSON if it looks like JSON
        if (result.raw) {
            try {
                const jsonMatch = result.raw.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    result.parsed = JSON.parse(jsonMatch[0]);
                }
            } catch (e) {
                // Not JSON, that's fine
            }
        }
        
        res.json({ 
            engine, 
            result: {
                raw: result.parsed || result.raw,
                reasoning: result.parsed?.reasoning || result.raw
            },
            usage: result.usage 
        });
        
    } catch (error) {
        console.error(`${engine} exception:`, error.message);
        res.status(500).json({ error: error.message });
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REDDIT SENTIMENT ENDPOINT (Multi-source, Sport-Specific)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.get('/api/reddit/sentiment', async (req, res) => {
    const { 
        player, 
        subreddit = 'sportsbook',
        sport = 'nba',
        subreddits = null, // comma-separated list
        limit = 100 
    } = req.query;
    
    if (!player) {
        return res.status(400).json({ error: 'Player name required' });
    }
    
    // Sport-specific subreddit mapping
    const SPORT_SUBREDDITS = {
        nba: ['nba', 'sportsbook', 'NBAbetting'],
        nfl: ['nfl', 'sportsbook', 'fantasyfootball'],
        mlb: ['baseball', 'sportsbook', 'fantasybaseball'],
        nhl: ['hockey', 'sportsbook', 'fantasyhockey'],
        ncaab: ['collegebasketball', 'sportsbook'],
        ncaaf: ['cfb', 'sportsbook'],
        soccer: ['soccer', 'sportsbook', 'SoccerBetting']
    };
    
    // Determine which subreddits to search
    let targetSubs;
    if (subreddits) {
        targetSubs = subreddits.split(',').map(s => s.trim());
    } else if (sport && SPORT_SUBREDDITS[sport.toLowerCase()]) {
        targetSubs = SPORT_SUBREDDITS[sport.toLowerCase()];
    } else {
        targetSubs = [subreddit];
    }
    
    // Props thread search term by sport
    const PROPS_THREAD_TERMS = {
        nba: 'NBA Props Daily',
        nfl: 'NFL Props',
        mlb: 'MLB Props Daily',
        nhl: 'NHL Props',
        ncaab: 'CBB Props',
        ncaaf: 'CFB Props',
        soccer: 'Soccer Props'
    };
    
    const propsSearchTerm = PROPS_THREAD_TERMS[sport?.toLowerCase()] || 'Props Daily';
    
    try {
        const allComments = [];
        const headers = {
            'User-Agent': 'SBA-GENIUS-Calculator/4.0 (Universal Sports Betting Analysis)'
        };
        
        // Build fetch promises for all subreddits
        const sources = [];
        
        for (const sub of targetSubs.slice(0, 3)) { // Max 3 subreddits
            // Recent comments from this subreddit
            sources.push(
                fetch(`https://www.reddit.com/r/${sub}/comments.json?limit=${Math.floor(limit / targetSubs.length)}`, { headers })
                    .then(r => ({ type: 'comments', sub, response: r }))
                    .catch(e => ({ type: 'comments', sub, error: e.message }))
            );
            // Search for player in this subreddit
            sources.push(
                fetch(`https://www.reddit.com/r/${sub}/search.json?q=${encodeURIComponent(player)}&restrict_sr=on&sort=new&t=day&limit=25`, { headers })
                    .then(r => ({ type: 'search', sub, response: r }))
                    .catch(e => ({ type: 'search', sub, error: e.message }))
            );
        }
        
        // Add props thread search (always from sportsbook)
        sources.push(
            fetch(`https://www.reddit.com/r/sportsbook/search.json?q=${encodeURIComponent(propsSearchTerm)}&restrict_sr=on&sort=new&t=day&limit=3`, { headers })
                .then(r => ({ type: 'props_thread', sub: 'sportsbook', response: r }))
                .catch(e => ({ type: 'props_thread', sub: 'sportsbook', error: e.message }))
        );
        
        const results = await Promise.all(sources);
        
        // Process all results
        for (const result of results) {
            if (result.error || !result.response?.ok) continue;
            
            try {
                const data = await result.response.json();
                
                if (result.type === 'comments') {
                    (data.data?.children || []).forEach(c => {
                        if (c.data?.body) allComments.push({ 
                            body: c.data.body, 
                            author: c.data.author, 
                            score: c.data.score, 
                            source: `${result.sub}/comments` 
                        });
                    });
                } else if (result.type === 'search') {
                    (data.data?.children || []).forEach(p => {
                        if (p.data?.selftext) allComments.push({ 
                            body: p.data.selftext, 
                            author: p.data.author, 
                            score: p.data.score, 
                            source: `${result.sub}/search` 
                        });
                        if (p.data?.title) allComments.push({ 
                            body: p.data.title, 
                            author: p.data.author, 
                            score: p.data.score, 
                            source: `${result.sub}/title` 
                        });
                    });
                } else if (result.type === 'props_thread') {
                    const threads = data.data?.children || [];
                    if (threads.length > 0) {
                        const threadId = threads[0].data?.id;
                        if (threadId) {
                            try {
                                const threadRes = await fetch(`https://www.reddit.com/r/sportsbook/comments/${threadId}.json?limit=200`, { headers });
                                if (threadRes.ok) {
                                    const threadData = await threadRes.json();
                                    if (Array.isArray(threadData) && threadData[1]) {
                                        (threadData[1].data?.children || []).forEach(c => {
                                            if (c.data?.body) allComments.push({ 
                                                body: c.data.body, 
                                                author: c.data.author, 
                                                score: c.data.score, 
                                                source: 'props_thread', 
                                                created: c.data.created_utc 
                                            });
                                        });
                                    }
                                }
                            } catch (e) { /* ignore */ }
                        }
                    }
                }
            } catch (e) { /* ignore parse errors */ }
        }
        
        // Filter for player mentions
        const playerLower = player.toLowerCase();
        const lastName = player.split(' ').pop().toLowerCase();
        const firstName = player.split(' ')[0]?.toLowerCase();
        
        const relevant = allComments.filter(c => {
            const body = (c.body || '').toLowerCase();
            return body.includes(playerLower) || body.includes(lastName) || (firstName?.length > 3 && body.includes(firstName));
        });
        
        // Analyze sentiment
        let overCount = 0, underCount = 0;
        const bullishKeywords = [], bearishKeywords = [];
        
        const overPatterns = /\bover\b|o\d+\.?\d*|smash|lock|hammer|ğŸ”¥|ğŸ’°|cash|hit|love|like|taking|riding|slamming|easy|money|confident|bet|play/gi;
        const underPatterns = /\bunder\b|u\d+\.?\d*|fade|trap|stay away|avoid|skip|pass|hate|don't like|scared|risky|sus|suspicious|moved|sharp/gi;
        
        relevant.forEach(c => {
            const body = c.body.toLowerCase();
            const oMatches = body.match(overPatterns) || [];
            const uMatches = body.match(underPatterns) || [];
            overCount += oMatches.length;
            underCount += uMatches.length;
            bullishKeywords.push(...oMatches.slice(0, 3));
            bearishKeywords.push(...uMatches.slice(0, 3));
        });
        
        const total = overCount + underCount;
        const sentimentScore = total > 0 ? Math.round(((overCount - underCount) / total) * 100) : 0;
        
        let sentimentLabel = 'NEUTRAL';
        if (sentimentScore >= 50) sentimentLabel = 'STRONG OVER';
        else if (sentimentScore >= 20) sentimentLabel = 'LEAN OVER';
        else if (sentimentScore <= -50) sentimentLabel = 'STRONG UNDER';
        else if (sentimentScore <= -20) sentimentLabel = 'LEAN UNDER';
        else if (relevant.length === 0) sentimentLabel = 'NO DATA';
        
        const samples = relevant
            .sort((a, b) => (b.score || 0) - (a.score || 0))
            .slice(0, 5)
            .map(c => ({ body: c.body.substring(0, 200), author: c.author, score: c.score, source: c.source }));
        
        res.json({
            success: true,
            player,
            sport,
            subreddits: targetSubs,
            totalComments: allComments.length,
            relevantMentions: relevant.length,
            sentiment: { score: sentimentScore, label: sentimentLabel, overMentions: overCount, underMentions: underCount },
            keywords: { bullish: [...new Set(bullishKeywords)].slice(0, 10), bearish: [...new Set(bearishKeywords)].slice(0, 10) },
            samples,
            sources: {
                comments: allComments.filter(c => c.source?.includes('comments')).length,
                search: allComments.filter(c => c.source?.includes('search')).length,
                props_thread: allComments.filter(c => c.source === 'props_thread').length
            },
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW: TWITTER/X SENTIMENT ENDPOINT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Note: Twitter API requires paid access. This uses alternative methods.
app.get('/api/twitter/sentiment', async (req, res) => {
    const { player, sport = 'nba' } = req.query;
    
    if (!player) {
        return res.status(400).json({ error: 'Player name required' });
    }
    
    try {
        // Method 1: Use Nitter (Twitter mirror) - may be blocked
        // Method 2: Use search aggregators
        // Method 3: Scrape betting Twitter accounts via RSS
        
        const playerLower = player.toLowerCase();
        const lastName = player.split(' ').pop().toLowerCase();
        
        // Try to get sentiment from betting-focused sources
        const sources = [];
        
        // Try Action Network (has Twitter-like feed)
        try {
            const actionRes = await fetch(`https://www.actionnetwork.com/api/web/v1/articles?sport=${sport}&limit=20`, {
                headers: { 'User-Agent': 'SBA-GENIUS/3.5' }
            });
            if (actionRes.ok) {
                const data = await actionRes.json();
                sources.push({ source: 'actionnetwork', data });
            }
        } catch (e) { /* ignore */ }
        
        // Aggregate from betting Twitter lists (via RSS bridges)
        // These are public feeds that aggregate betting Twitter
        const rssBridges = [
            // Add RSS feed URLs here when available
        ];
        
        // For now, return estimated sentiment based on player popularity
        // This will be enhanced when Twitter API access is available
        
        // Use Perplexity to get real-time Twitter sentiment (if API key available)
        if (KEYS.perplexity) {
            try {
                const perplexityRes = await fetch('https://api.perplexity.ai/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${KEYS.perplexity}`
                    },
                    body: JSON.stringify({
                        model: 'sonar-pro',
                        messages: [{
                            role: 'user',
                            content: `What is the current Twitter/X sentiment about ${player} ${sport.toUpperCase()} player props betting today? 
                            Look for recent tweets about their over/under lines.
                            Return ONLY JSON: {"sentiment": "BULLISH/BEARISH/NEUTRAL", "score": -100 to 100, "summary": "brief summary", "tweetCount": estimated number}`
                        }]
                    })
                });
                
                if (perplexityRes.ok) {
                    const data = await perplexityRes.json();
                    const content = data.choices?.[0]?.message?.content || '';
                    
                    try {
                        const jsonMatch = content.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const parsed = JSON.parse(jsonMatch[0]);
                            return res.json({
                                success: true,
                                player,
                                source: 'perplexity_realtime',
                                sentiment: {
                                    label: parsed.sentiment || 'NEUTRAL',
                                    score: parsed.score || 0,
                                    summary: parsed.summary || 'No data available'
                                },
                                estimatedTweets: parsed.tweetCount || 0,
                                timestamp: new Date().toISOString(),
                                note: 'Sentiment derived from real-time web search'
                            });
                        }
                    } catch (e) { /* parsing failed */ }
                }
            } catch (e) { /* perplexity failed */ }
        }
        
        // Fallback response
        res.json({
            success: true,
            player,
            source: 'unavailable',
            sentiment: {
                label: 'UNKNOWN',
                score: 0,
                summary: 'Twitter API requires paid access. Consider using Reddit sentiment instead.'
            },
            timestamp: new Date().toISOString(),
            note: 'Full Twitter integration requires Twitter API v2 access ($100/month). Reddit sentiment is recommended as a free alternative.'
        });
        
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW: LIVE GAME TRACKING ENDPOINTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Get live scores for a sport
app.get('/api/live/:sport/scores', async (req, res) => {
    const { sport } = req.params;
    
    try {
        // Use ESPN's public API for live scores
        const sportMap = {
            'nba': 'basketball/nba',
            'nfl': 'football/nfl',
            'mlb': 'baseball/mlb',
            'nhl': 'hockey/nhl',
            'ncaab': 'basketball/mens-college-basketball',
            'ncaaf': 'football/college-football'
        };
        
        const espnSport = sportMap[sport.toLowerCase()] || 'basketball/nba';
        const url = `https://site.api.espn.com/apis/site/v2/sports/${espnSport}/scoreboard`;
        
        const response = await fetch(url, {
            headers: { 'User-Agent': 'SBA-GENIUS/3.5' }
        });
        
        if (!response.ok) {
            return res.status(response.status).json({ error: 'ESPN API error' });
        }
        
        const data = await response.json();
        const games = (data.events || []).map(event => {
            const competition = event.competitions?.[0];
            const homeTeam = competition?.competitors?.find(c => c.homeAway === 'home');
            const awayTeam = competition?.competitors?.find(c => c.homeAway === 'away');
            
            return {
                id: event.id,
                name: event.name,
                shortName: event.shortName,
                status: {
                    type: competition?.status?.type?.name,
                    description: competition?.status?.type?.description,
                    detail: competition?.status?.type?.detail,
                    clock: competition?.status?.displayClock,
                    period: competition?.status?.period
                },
                home: {
                    id: homeTeam?.team?.id,
                    name: homeTeam?.team?.displayName,
                    abbreviation: homeTeam?.team?.abbreviation,
                    score: homeTeam?.score,
                    record: homeTeam?.records?.[0]?.summary
                },
                away: {
                    id: awayTeam?.team?.id,
                    name: awayTeam?.team?.displayName,
                    abbreviation: awayTeam?.team?.abbreviation,
                    score: awayTeam?.score,
                    record: awayTeam?.records?.[0]?.summary
                },
                venue: competition?.venue?.fullName,
                broadcast: competition?.broadcasts?.[0]?.names?.[0],
                odds: competition?.odds?.[0] ? {
                    spread: competition.odds[0].details,
                    overUnder: competition.odds[0].overUnder,
                    provider: competition.odds[0].provider?.name
                } : null,
                startTime: event.date
            };
        });
        
        res.json({
            success: true,
            sport: sport.toUpperCase(),
            gamesCount: games.length,
            games,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Get detailed live game data including player stats
app.get('/api/live/:sport/:gameId', async (req, res) => {
    const { sport, gameId } = req.params;
    const { player } = req.query;
    
    try {
        const sportMap = {
            'nba': 'basketball/nba',
            'nfl': 'football/nfl',
            'mlb': 'baseball/mlb',
            'nhl': 'hockey/nhl'
        };
        
        const espnSport = sportMap[sport.toLowerCase()] || 'basketball/nba';
        
        // Get game summary
        const summaryUrl = `https://site.api.espn.com/apis/site/v2/sports/${espnSport}/summary?event=${gameId}`;
        const response = await fetch(summaryUrl, {
            headers: { 'User-Agent': 'SBA-GENIUS/3.5' }
        });
        
        if (!response.ok) {
            return res.status(response.status).json({ error: 'ESPN API error' });
        }
        
        const data = await response.json();
        
        // Extract player stats if available
        const boxscore = data.boxscore;
        const playerStats = [];
        
        if (boxscore?.players) {
            boxscore.players.forEach(team => {
                (team.statistics || []).forEach(statGroup => {
                    (statGroup.athletes || []).forEach(athlete => {
                        const stats = {};
                        (statGroup.labels || []).forEach((label, idx) => {
                            stats[label.toLowerCase()] = athlete.stats?.[idx];
                        });
                        
                        playerStats.push({
                            id: athlete.athlete?.id,
                            name: athlete.athlete?.displayName,
                            shortName: athlete.athlete?.shortName,
                            team: team.team?.abbreviation,
                            position: athlete.athlete?.position?.abbreviation,
                            stats
                        });
                    });
                });
            });
        }
        
        // If player specified, filter and highlight
        let playerData = null;
        if (player) {
            const playerLower = player.toLowerCase();
            playerData = playerStats.find(p => 
                p.name?.toLowerCase().includes(playerLower) ||
                p.shortName?.toLowerCase().includes(playerLower)
            );
        }
        
        // Get current game state
        const gameState = {
            id: gameId,
            status: data.header?.competitions?.[0]?.status,
            homeScore: data.header?.competitions?.[0]?.competitors?.find(c => c.homeAway === 'home')?.score,
            awayScore: data.header?.competitions?.[0]?.competitors?.find(c => c.homeAway === 'away')?.score,
            clock: data.header?.competitions?.[0]?.status?.displayClock,
            period: data.header?.competitions?.[0]?.status?.period,
            isLive: data.header?.competitions?.[0]?.status?.type?.state === 'in'
        };
        
        res.json({
            success: true,
            game: gameState,
            playerStats: player ? playerData : playerStats.slice(0, 20),
            playerRequested: player || null,
            leaders: data.leaders,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Get live player stats during a game
app.get('/api/live/:sport/player/:playerId', async (req, res) => {
    const { sport, playerId } = req.params;
    
    try {
        // ESPN athlete endpoint
        const url = `https://site.api.espn.com/apis/common/v3/sports/${sport}/athletes/${playerId}`;
        
        const response = await fetch(url, {
            headers: { 'User-Agent': 'SBA-GENIUS/3.5' }
        });
        
        if (!response.ok) {
            return res.status(response.status).json({ error: 'ESPN API error' });
        }
        
        const data = await response.json();
        
        res.json({
            success: true,
            player: {
                id: data.athlete?.id,
                name: data.athlete?.displayName,
                team: data.athlete?.team?.displayName,
                position: data.athlete?.position?.name,
                jersey: data.athlete?.jersey,
                stats: data.athlete?.statistics
            },
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HEALTH CHECK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
app.get('/health', (req, res) => {
    res.json({ status: 'healthy', version: '4.0.0', timestamp: new Date().toISOString() });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HIGHLIGHTLY API PROXY ROUTES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 14 endpoints for NBA/NCAAB match data, predictions, odds, stats, and more
// Requires: HIGHLIGHTLY_API_KEY environment variable in Railway
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const HIGHLIGHTLY_BASE = 'https://nba.highlightly.net';
const HIGHLIGHTLY_KEY = process.env.HIGHLIGHTLY_API_KEY || '';

// Generic Highlightly proxy handler
async function highlightlyProxy(endpoint, queryParams, res) {
    if (!HIGHLIGHTLY_KEY) {
        return res.status(500).json({ error: 'HIGHLIGHTLY_API_KEY not configured' });
    }
    
    try {
        const url = new URL(`${HIGHLIGHTLY_BASE}${endpoint}`);
        for (const [k, v] of Object.entries(queryParams || {})) {
            if (v !== undefined && v !== null && v !== '') {
                url.searchParams.set(k, v);
            }
        }
        
        console.log(`ğŸ€ Highlightly proxy: ${endpoint} â†’ ${url.toString()}`);
        
        const resp = await fetch(url.toString(), {
            headers: { 'x-rapidapi-key': HIGHLIGHTLY_KEY }
        });
        
        // Forward rate limit headers
        const remaining = resp.headers.get('x-ratelimit-requests-remaining');
        const limit = resp.headers.get('x-ratelimit-requests-limit');
        if (remaining) res.set('x-hl-remaining', remaining);
        if (limit) res.set('x-hl-limit', limit);
        
        if (!resp.ok) {
            const text = await resp.text().catch(() => '');
            console.warn(`âš ï¸ Highlightly ${endpoint}: HTTP ${resp.status} â€” ${text.slice(0, 200)}`);
            return res.status(resp.status).json({ 
                error: `Highlightly API error`, 
                status: resp.status,
                detail: text.slice(0, 200)
            });
        }
        
        const data = await resp.json();
        return res.json(data);
    } catch (e) {
        console.error(`âŒ Highlightly proxy error: ${e.message}`);
        return res.status(500).json({ error: e.message });
    }
}

// â”€â”€â”€ MATCHES: Today's games â”€â”€â”€
app.get('/api/highlightly/matches', (req, res) => {
    const { league, date, timezone, season, limit, offset, 
            homeTeamId, awayTeamId, homeTeamName, awayTeamName,
            homeTeamAbbreviation, awayTeamAbbreviation,
            homeTeamDisplayName, awayTeamDisplayName } = req.query;
    highlightlyProxy('/matches', { 
        league, date, timezone: timezone || 'America/New_York', 
        season, limit: limit || 100, offset: offset || 0,
        homeTeamId, awayTeamId, homeTeamName, awayTeamName,
        homeTeamAbbreviation, awayTeamAbbreviation,
        homeTeamDisplayName, awayTeamDisplayName
    }, res);
});

// â”€â”€â”€ MATCH DETAIL: Predictions, stats, events â”€â”€â”€
app.get('/api/highlightly/match/:id', (req, res) => {
    highlightlyProxy(`/matches/${req.params.id}`, {}, res);
});

// â”€â”€â”€ ODDS: Multi-bookmaker (requires paid plan) â”€â”€â”€
app.get('/api/highlightly/odds', (req, res) => {
    const { matchId, oddsType, leagueName, bookmakerId, bookmakerName, 
            date, timezone, limit, offset } = req.query;
    highlightlyProxy('/odds', { 
        matchId, oddsType: oddsType || 'prematch', leagueName,
        bookmakerId, bookmakerName, date, timezone,
        limit: limit || 5, offset: offset || 0 
    }, res);
});

// â”€â”€â”€ TEAMS: Search/lookup â”€â”€â”€
app.get('/api/highlightly/teams', (req, res) => {
    const { name, displayName, abbreviation, league } = req.query;
    highlightlyProxy('/teams', { name, displayName, abbreviation, league }, res);
});

// â”€â”€â”€ TEAM STATS: Total/Home/Away splits â”€â”€â”€
app.get('/api/highlightly/team-stats/:id', (req, res) => {
    const { fromDate, timezone } = req.query;
    highlightlyProxy(`/teams/statistics/${req.params.id}`, { 
        fromDate: fromDate || '2025-11-01', 
        timezone: timezone || 'America/New_York' 
    }, res);
});

// â”€â”€â”€ TEAM BY ID â”€â”€â”€
app.get('/api/highlightly/team/:id', (req, res) => {
    highlightlyProxy(`/teams/${req.params.id}`, {}, res);
});

// â”€â”€â”€ STANDINGS: Conference/league â”€â”€â”€
app.get('/api/highlightly/standings', (req, res) => {
    const { leagueType, leagueName, abbreviation, year, limit, offset } = req.query;
    highlightlyProxy('/standings', { 
        leagueType: leagueType || 'NCAA', leagueName, abbreviation, 
        year, limit: limit || 10, offset: offset || 0 
    }, res);
});

// â”€â”€â”€ HEAD TO HEAD: Last 10 H2H games â”€â”€â”€
app.get('/api/highlightly/h2h', (req, res) => {
    const { teamIdOne, teamIdTwo } = req.query;
    if (!teamIdOne || !teamIdTwo) {
        return res.status(400).json({ error: 'teamIdOne and teamIdTwo required' });
    }
    highlightlyProxy('/head-2-head', { teamIdOne, teamIdTwo }, res);
});

// â”€â”€â”€ LAST 5 GAMES: Team form â”€â”€â”€
app.get('/api/highlightly/last5', (req, res) => {
    const { teamId } = req.query;
    if (!teamId) return res.status(400).json({ error: 'teamId required' });
    highlightlyProxy('/last-five-games', { teamId }, res);
});

// â”€â”€â”€ BOX SCORE: Per-player stats â”€â”€â”€
app.get('/api/highlightly/box-score/:matchId', (req, res) => {
    highlightlyProxy(`/box-score/${req.params.matchId}`, {}, res);
});

// â”€â”€â”€ LINEUPS: Pregame lineups â”€â”€â”€
app.get('/api/highlightly/lineups/:matchId', (req, res) => {
    highlightlyProxy(`/lineups/${req.params.matchId}`, {}, res);
});

// â”€â”€â”€ HIGHLIGHTS: Game clips & recaps â”€â”€â”€
app.get('/api/highlightly/highlights', (req, res) => {
    const { matchId, leagueName, date, timezone, season, limit, offset,
            homeTeamId, awayTeamId } = req.query;
    highlightlyProxy('/highlights', { 
        matchId, leagueName, date, timezone, season,
        homeTeamId, awayTeamId,
        limit: limit || 10, offset: offset || 0 
    }, res);
});

// â”€â”€â”€ BOOKMAKERS: List supported books â”€â”€â”€
app.get('/api/highlightly/bookmakers', (req, res) => {
    const { name, limit, offset } = req.query;
    highlightlyProxy('/bookmakers', { name, limit: limit || 100, offset: offset || 0 }, res);
});

// â”€â”€â”€ PLAYERS: Search players â”€â”€â”€
app.get('/api/highlightly/players', (req, res) => {
    const { name, limit, offset } = req.query;
    highlightlyProxy('/players', { name, limit: limit || 100, offset: offset || 0 }, res);
});

// â”€â”€â”€ PLAYER DETAIL: By ID â”€â”€â”€
app.get('/api/highlightly/player/:id', (req, res) => {
    highlightlyProxy(`/players/${req.params.id}`, {}, res);
});

// â”€â”€â”€ PLAYER STATS: Season stats by ID â”€â”€â”€
app.get('/api/highlightly/player/:id/stats', (req, res) => {
    highlightlyProxy(`/players/${req.params.id}/statistics`, {}, res);
});

// â”€â”€â”€ STATUS: Check if Highlightly is configured â”€â”€â”€
app.get('/api/highlightly/status', (req, res) => {
    res.json({
        configured: !!HIGHLIGHTLY_KEY,
        keyPresent: HIGHLIGHTLY_KEY.length > 0,
        keyPreview: HIGHLIGHTLY_KEY ? `${HIGHLIGHTLY_KEY.slice(0, 8)}...` : 'not set',
        endpoints: [
            'GET /api/highlightly/matches',
            'GET /api/highlightly/match/:id',
            'GET /api/highlightly/odds',
            'GET /api/highlightly/teams',
            'GET /api/highlightly/team-stats/:id',
            'GET /api/highlightly/standings',
            'GET /api/highlightly/h2h',
            'GET /api/highlightly/last5',
            'GET /api/highlightly/box-score/:matchId',
            'GET /api/highlightly/lineups/:matchId',
            'GET /api/highlightly/highlights',
            'GET /api/highlightly/players',
            'GET /api/highlightly/player/:id',
            'GET /api/highlightly/player/:id/stats'
        ]
    });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// START SERVER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`\nğŸ† SBA AI Proxy V4.0 - Universal Sports Edition`);
    console.log(`   Running on port ${PORT}\n`);
    console.log('ğŸ“Š Endpoints:');
    console.log('   GET  /                      - Status & configured engines');
    console.log('   GET  /api/ai/status         - AI engine availability');
    console.log('   POST /api/ai/:engine        - Query AI engine');
    console.log('   GET  /api/reddit/sentiment  - Reddit sentiment (sport-specific)');
    console.log('   GET  /api/twitter/sentiment - Twitter sentiment (via Perplexity)');
    console.log('   GET  /api/live/:sport/scores - Live scores');
    console.log('   GET  /api/live/:sport/:gameId - Live game details');
    console.log('   GET  /api/highlightly/*      - Highlightly API (14 endpoints)');
    console.log('');
    
    // Log configured engines
    const configured = Object.entries(KEYS).filter(([k, v]) => v).map(([k]) => k);
    console.log(`ğŸ”‘ Configured API Keys: ${configured.length}/11`);
    console.log(`   ${configured.join(', ') || 'None'}`);
    console.log('');
    console.log(`ğŸ€ Highlightly API: ${HIGHLIGHTLY_KEY ? 'âœ… Configured' : 'âŒ No API key'}`);
    console.log(`   14 endpoints at /api/highlightly/*`);
    console.log('');
    console.log('ğŸ° SUPPORTED SPORTS: NBA, NFL, MLB, NHL, NCAAB, NCAAF, Soccer');
    console.log('');
});
